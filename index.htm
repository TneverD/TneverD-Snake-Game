<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TneverD Snake Game</title>
  <style>
    :root {
      --bg-dark: #0f1724; --card-dark: #0b1220; --accent-dark: #00E7A8; --muted-dark: #9aa4b2; --glass-dark: rgba(255,255,255,0.04);
      --bg-light: #f9fafb; --card-light: #ffffff; --accent-light: #059669; --muted-light: #555; --glass-light: rgba(0,0,0,0.05);
      --radius: 14px;
      --mono: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }
    body {
      margin: 0; font-family: var(--mono);
      background: var(--bg-dark);
      color: #e6eef6;
      transition: background 0.4s, color 0.4s;
      overflow-x: hidden;
    }
    body.light {
      background: var(--bg-light);
      color: #111;
    }
    .app {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    .wrap {
      width: 100%;
      max-width: 1200px;
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
    }
    @media (max-width: 980px) {
      .wrap {
        grid-template-columns: 1fr;
        max-width: 600px;
      }
      .app {
        padding: 15px;
      }
    }
    @media (max-width: 480px) {
      .app {
        padding: 10px;
      }
      .wrap {
        gap: 15px;
      }
    }
    .panel {
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.6);
      transition: background 0.4s, color 0.4s;
    }
    body.light .panel {
      background: var(--card-light);
      box-shadow: 0 6px 20px rgba(0,0,0,0.1);
      color: #222;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      background: linear-gradient(180deg,#061424,#072238);
      border-radius: 10px;
      box-shadow: inset 0 0 40px rgba(0,0,0,0.5);
      transition: background 0.4s;
      aspect-ratio: 1;
    }
    body.light canvas {
      background: linear-gradient(180deg,#d7e6f0,#f0f6fb);
      box-shadow: inset 0 0 40px rgba(0,0,0,0.1);
    }
    .hud {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 12px;
    }
    @media (max-width: 480px) {
      .hud {
        gap: 6px;
        font-size: 14px;
      }
    }
    .chip {
      background: var(--glass-dark);
      padding: 8px 12px;
      border-radius: 999px;
      font-weight: 600;
      color: var(--accent-dark);
      display: inline-flex;
      gap: 8px;
      align-items: center;
      user-select: none;
      transition: background 0.4s, color 0.4s;
      font-size: 14px;
    }
    @media (max-width: 480px) {
      .chip {
        padding: 6px 10px;
        font-size: 12px;
      }
    }
    body.light .chip {
      background: var(--glass-light);
      color: var(--accent-light);
    }
    .col {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    @media (max-width: 480px) {
      .controls {
        gap: 6px;
      }
    }
    button.btn {
      background: linear-gradient(90deg, var(--accent-dark), #4EE2C1);
      border: none;
      padding: 9px 14px;
      border-radius: 10px;
      color: #022;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      user-select: none;
      transition: background 0.4s, color 0.4s;
      font-size: 14px;
    }
    @media (max-width: 480px) {
      button.btn {
        padding: 8px 12px;
        font-size: 12px;
      }
    }
    body.light button.btn {
      background: linear-gradient(90deg, var(--accent-light), #3DB17E);
      color: #fff;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
    }
    button.ghost {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.06);
      color: var(--muted-dark);
      padding: 8px 12px;
      user-select: none;
      transition: border-color 0.4s, color 0.4s;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
    }
    @media (max-width: 480px) {
      button.ghost {
        padding: 6px 10px;
        font-size: 12px;
      }
    }
    body.light button.ghost {
      border: 1px solid rgba(0,0,0,0.1);
      color: var(--muted-light);
    }
    .settings {
      margin-top: 14px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
    }
    @media (max-width: 480px) {
      .settings {
        grid-template-columns: 1fr;
        gap: 8px;
      }
    }
    .setting {
      background: rgba(255,255,255,0.02);
      padding: 10px;
      border-radius: 10px;
      user-select: none;
      transition: background 0.4s, color 0.4s;
    }
    body.light .setting {
      background: rgba(0,0,0,0.03);
      color: #222;
    }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted-dark);
      margin-bottom: 6px;
      user-select: none;
    }
    body.light label {
      color: var(--muted-light);
    }
    input[type=range], select {
      width: 100%;
      font-size: 12px;
    }
    .footer {
      font-size: 12px;
      color: var(--muted-dark);
      margin-top: 12px;
      user-select: none;
    }
    @media (max-width: 480px) {
      .footer {
        font-size: 11px;
      }
    }
    body.light .footer {
      color: var(--muted-light);
    }
    .right {
      display: flex;
      flex-direction: column;
    }
    .panel.right {
      height: fit-content;
      display: flex;
      flex-direction: column;
    }
    .scoreboard {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
    }
    @media (max-width: 480px) {
      .scoreboard {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
    }
    .list {
      margin-top: 12px;
      display: grid;
      gap: 8px;
    }
    .stat {
      background: rgba(255,255,255,0.02);
      padding: 10px;
      border-radius: 8px;
      display: flex;
      justify-content: space-between;
      user-select: none;
      transition: background 0.4s, color 0.4s;
      font-size: 14px;
    }
    body.light .stat {
      background: rgba(0,0,0,0.03);
      color: #222;
    }
    .mobile-pad {
      display: none;
      margin-top: 15px;
      background: rgba(255,255,255,0.02);
      padding: 15px;
      border-radius: 12px;
      justify-content: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    body.light .mobile-pad {
      background: rgba(0,0,0,0.03);
    }
    @media (max-width: 980px) {
      .mobile-pad {
        display: flex;
        order: -1;
      }
    }
    .mobile-pad button {
      min-width: 50px;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
    }
    @media (max-width: 480px) {
      .mobile-pad button {
        min-width: 45px;
        min-height: 45px;
        font-size: 18px;
      }
    }
    .logo {
      font-weight: 800;
      color: var(--accent-dark);
      letter-spacing: 1px;
      user-select: none;
      transition: color 0.4s;
    }
    @media (max-width: 480px) {
      .logo {
        font-size: 18px;
      }
    }
    body.light .logo {
      color: var(--accent-light);
    }
    #toggleThemeBtn {
      font-size: 22px;
      background: transparent;
      border: none;
      cursor: pointer;
      user-select: none;
      transition: color 0.4s;
      color: var(--accent-dark);
      padding: 6px 10px;
      border-radius: 10px;
    }
    body.light #toggleThemeBtn {
      color: var(--accent-light);
    }
    .auto-active {
      background: linear-gradient(90deg, #ff6b35, #ff8e53) !important;
      color: #fff !important;
    }
    .header-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    @media (max-width: 480px) {
      .header-controls {
        gap: 4px;
      }
    }
  </style>
</head>
<body>
  <div class="app" tabindex="0">
    <div class="wrap">
      <div class="panel">

        <div class="scoreboard">
          <div>
            <div class="logo">TNEVERD SNAKE GAME</div>
            <div style="font-size:12px;color:var(--muted-dark); user-select:none;">A Simple Snake game with Modern Style!</div>
          </div>
          <div class="header-controls">
            <button id="toggleThemeBtn" title="Toggle Dark/Light Mode" aria-label="Toggle theme">üåô</button>
            <button id="fullscreenBtn" title="Toggle Fullscreen" aria-label="Toggle fullscreen" class="ghost">‚õ∂</button>
            <div class="chip" id="statusChip">Ready</div>
          </div>
        </div>

        <div style="margin-top:12px;">
          <canvas id="gameCanvas" width="640" height="640" tabindex="0"></canvas>
        </div>

        <!-- ÿØ⁄©ŸÖŸá‚ÄåŸáÿß€å ŸÖŸàÿ®ÿß€åŸÑ: ŸÖŸÜÿ™ŸÇŸÑ‚Äåÿ¥ÿØŸá ÿ®Ÿá ÿ≤€åÿ± Canvas -->
        <div class="mobile-pad" style="display:flex;justify-content:center;gap:8px;margin-top:12px;">
          <button id="upTouch" class="ghost">‚¨ÜÔ∏è</button>
          <button id="leftTouch" class="ghost">‚¨ÖÔ∏è</button>
          <button id="downTouch" class="ghost">‚¨áÔ∏è</button>
          <button id="rightTouch" class="ghost">‚û°Ô∏è</button>
        </div>

        <div class="hud">
          <div class="chip">Score: <span id="score">0</span></div>
          <div class="chip">High: <span id="high">0</span></div>
          <div class="chip">Speed: <span id="speedDisplay">8</span></div>
          <div class="chip">Length: <span id="length">1</span></div>
        </div>

        <div class="controls" style="margin-top:12px">
          <button class="btn" id="startBtn">Start</button>
          <button class="ghost" id="pauseBtn">Pause</button>
          <button class="ghost" id="restartBtn">Restart</button>
          <button class="ghost" id="autoBtn">Auto Play</button>
          <div style="flex:1"></div>
          <div style="display:flex;gap:8px;align-items:center">
            <button class="ghost" id="saveBtn">Save</button>
            <button class="ghost" id="loadBtn">Load</button>
          </div>
        </div>

        <div class="settings">
          <div class="setting">
            <label for="speed">Speed</label>
            <input id="speed" type="range" min="3" max="25" value="8" />
          </div>
          <div class="setting">
            <label for="grid">Grid size</label>
            <input id="grid" type="range" min="10" max="40" value="20" />
          </div>
          <div class="setting">
            <label for="obstacleMode">Obstacles</label>
            <select id="obstacleMode">
              <option value="none">None</option>
              <option value="random">Random</option>
              <option value="maze">Maze</option>
            </select>
          </div>
          <div class="setting">
            <label for="powerups">Power-ups</label>
            <select id="powerups">
              <option value="on">On</option>
              <option value="off">Off</option>
            </select>
          </div>
          <div class="setting">
            <label for="skin">Skin</label>
            <select id="skin">
              <option value="neon">Neon</option>
              <option value="pixel">Pixel</option>
              <option value="classic">Classic</option>
            </select>
          </div>
          <div class="setting">
            <label for="wrap">Wrap edges</label>
            <select id="wrap">
              <option value="true">On</option>
              <option value="false">Off</option>
            </select>
          </div>
        </div>

        <div class="footer">Controls: Arrow keys / WASD, swipe on mobile. <strong>ESC</strong> to exit fullscreen or pause. Enjoy!</div>
      </div>

      <div class="panel right">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:800">Stats & Options</div>
          <div style="font-size:12px;color:var(--muted-dark)">(C) TneverD-Software</div>
        </div>

        <div class="list">
          <div class="stat"><div>Last Score</div><div id="lastScore">‚Äî</div></div>
          <div class="stat"><div>Longest</div><div id="longest">‚Äî</div></div>
          <div class="stat"><div>Games Played</div><div id="played">0</div></div>
          <div class="stat"><div>Obstacles</div><div id="obCount">0</div></div>
          <div class="stat"><div>Power ups active</div><div id="pwrCount">0</div></div>
        </div>
      </div>
    </div>
  </div>
  <script>
    console.log("JavaScript Connected.");
    console.log("loading Scripts...");
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const restartBtn = document.getElementById('restartBtn');
      const autoBtn = document.getElementById('autoBtn');
      const speedInput = document.getElementById('speed');
      const gridInput = document.getElementById('grid');
      const obstacleMode = document.getElementById('obstacleMode');
      const powerupsSel = document.getElementById('powerups');
      const skinSel = document.getElementById('skin');
      const wrapSel = document.getElementById('wrap');
      const toggleThemeBtn = document.getElementById('toggleThemeBtn');
      const fullscreenBtn = document.getElementById('fullscreenBtn');
      const statusChip = document.getElementById('statusChip');

      const scoreEl = document.getElementById('score');
      const highEl = document.getElementById('high');
      const speedDisplay = document.getElementById('speedDisplay');
      const lengthEl = document.getElementById('length');
      const lastScore = document.getElementById('lastScore');
      const longest = document.getElementById('longest');
      const played = document.getElementById('played');
      const obCount = document.getElementById('obCount');
      const pwrCount = document.getElementById('pwrCount');

      const upTouch = document.getElementById('upTouch');
      const downTouch = document.getElementById('downTouch');
      const leftTouch = document.getElementById('leftTouch');
      const rightTouch = document.getElementById('rightTouch');

      // Game variables
      let W = canvas.width;
      let H = canvas.height;
      let grid = parseInt(gridInput.value);
      let cellSize = W / grid;

      let snake = [];
      let dir = {x:1,y:0};
      let nextDir = {x:1,y:0};
      let food = null;
      let obstacles = [];
      let powerups = [];
      let speed = parseInt(speedInput.value);
      let lengthTarget = 1;
      let score = 0;
      let highScore = 0;
      let gameInterval = null;
      let paused = false;
      let playing = false;
      let gameOver = false;
      let wrap = true;
      let autoPlay = false;

      // stats
      let gamesPlayed = 0;
      let longestLength = 1;

      // skins
      const skins = {
        neon: {
          bg: ['#020916','#041432'],
          snakeHead: '#00FFD1',
          snakeBody: '#00CBA0',
          food: '#FF0033',
          obstacle: '#FF00CC',
          powerup: '#00FFFF',
        },
        pixel: {
          bg: ['#222','#444'],
          snakeHead: '#76b900',
          snakeBody: '#a0d300',
          food: '#e8aa0a',
          obstacle: '#d34b1f',
          powerup: '#f0e68c',
        },
        classic: {
          bg: ['#061424','#072238'],
          snakeHead: '#3bd458',
          snakeBody: '#1e832c',
          food: '#d62929',
          obstacle: '#853535',
          powerup: '#70b570',
        }
      };

      let currentSkin = skins[skinSel.value];

      // Load saved theme from localStorage
      let darkMode = localStorage.getItem('tndSnakeDarkMode') !== 'false';
      
      function updateTheme(){
        if(darkMode) {
          document.body.classList.remove('light');
          toggleThemeBtn.textContent = 'üåô';
          toggleThemeBtn.title = 'Switch to Light Mode';
        } else {
          document.body.classList.add('light');
          toggleThemeBtn.textContent = '‚òÄÔ∏è';
          toggleThemeBtn.title = 'Switch to Dark Mode';
        }
        localStorage.setItem('tndSnakeDarkMode', darkMode);
      }
      
      toggleThemeBtn.onclick = ()=>{
        darkMode = !darkMode;
        updateTheme();
        draw();
      };
      updateTheme();

      // fullscreen toggle
      fullscreenBtn.onclick = () => {
        if (!document.fullscreenElement) {
          canvas.requestFullscreen().catch(() => {
            statusChip.textContent = "Fullscreen not supported";
            setTimeout(() => { 
              statusChip.textContent = gameOver ? "Game Over!" : (playing ? (paused ? "Paused" : "Playing") : "Ready"); 
            }, 2000);
          });
        } else {
          document.exitFullscreen();
        }
      };

      // prevent arrow & WASD keys from scrolling page when canvas focused
      window.addEventListener('keydown', (e) => {
        const keysToPrevent = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','w','a','s','d','W','A','S','D'];
        if(keysToPrevent.includes(e.key)){
          if(document.activeElement === canvas || document.body.classList.contains('playing')){
            e.preventDefault();
          }
        }
        // ESC: pause or exit fullscreen
        if(e.key === 'Escape'){
          if(document.fullscreenElement){
            document.exitFullscreen();
          } else if(playing && !gameOver){
            togglePause();
          }
        }
        // P pause toggle
        if(e.key.toLowerCase() === 'p'){
          if(playing && !gameOver) togglePause();
        }
      }, {passive:false});

      // handle focus for canvas to keep keys working
      canvas.setAttribute('tabindex','0');

      // Resize canvas & recalc sizes
      function resizeCanvas() {
        const container = canvas.parentElement;
        const containerWidth = container.clientWidth - 36; // account for padding
        const size = Math.min(640, containerWidth);
        canvas.width = size;
        canvas.height = size;
        W = canvas.width;
        H = canvas.height;
        cellSize = W / grid;
      }
      
      window.addEventListener('resize', () => {
        resizeCanvas();
        draw();
      });
      resizeCanvas();

      // Game functions
      function resetGame(){
        snake = [{x:Math.floor(grid/2), y:Math.floor(grid/2)}];
        dir = {x:1,y:0};
        nextDir = {x:1,y:0};
        lengthTarget = 1;
        score = 0;
        food = null;
        obstacles = generateObstacles(obstacleMode.value);
        powerups = [];
        playing = false;
        paused = false;
        gameOver = false;
        updateStats();
        draw();
        statusChip.textContent = 'Ready';
      }

      function generateObstacles(mode){
        let obs = [];
        if(mode === 'random'){
          for(let i=0;i<Math.floor(grid*grid*0.06);i++){
            let x, y, ok;
            do{
              x = Math.floor(Math.random()*grid);
              y = Math.floor(Math.random()*grid);
              ok = 
                !snake.some(s=>s.x===x && s.y===y) &&
                !(food && food.x===x && food.y===y) &&
                !powerups.some(p=>p.x===x && p.y===y) &&
                !obs.some(o=>o.x===x && o.y===y);
            }while(!ok);
            obs.push({x,y});
          }
        } else if(mode === 'maze'){
          for(let i=1;i<grid-1;i+=2){
            for(let j=1;j<grid-1;j+=2){
              obs.push({x:i,y:j});
            }
          }
        }
        obCount.textContent = obs.length;
        return obs;
      }

      function placeFood(){
        let attempts=0;
        do{
          food = {x:Math.floor(Math.random()*grid), y:Math.floor(Math.random()*grid)};
          attempts++;
          if(attempts>500) break;
        }while(
          snake.some(s=>s.x===food.x && s.y===food.y) ||
          obstacles.some(o=>o.x===food.x && o.y===food.y) ||
          powerups.some(p=>p.x===food.x && p.y===food.y)
        );
      }

      function placePowerup(){
        if(powerupsSel.value === 'off') return;
        if(powerups.length>3) return;
        let attempts=0;
        let pwr;
        do{
          pwr = {x:Math.floor(Math.random()*grid), y:Math.floor(Math.random()*grid)};
          attempts++;
          if(attempts>500) return;
        }while(
          snake.some(s=>s.x===pwr.x && s.y===pwr.y) ||
          obstacles.some(o=>o.x===pwr.x && o.y===pwr.y) ||
          powerups.some(p=>p.x===pwr.x && p.y===pwr.y) ||
          (food && food.x === pwr.x && food.y === pwr.y)
        );
        const types = ['speedup','slowdown','scoreMulti','shrink'];
        pwr.type = types[Math.floor(Math.random()*types.length)];
        powerups.push(pwr);
        pwrCount.textContent = powerups.length;
      }

      function draw(){
        let grad = ctx.createLinearGradient(0,0,0,H);
        grad.addColorStop(0, currentSkin.bg[0]);
        grad.addColorStop(1, currentSkin.bg[1]);
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,W,H);

        if(grid <= 25){
          ctx.strokeStyle = darkMode ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.1)';
          ctx.lineWidth = 1;
          for(let x=0;x<=grid;x++){
            ctx.beginPath();
            ctx.moveTo(x*cellSize,0);
            ctx.lineTo(x*cellSize,H);
            ctx.stroke();
          }
          for(let y=0;y<=grid;y++){
            ctx.beginPath();
            ctx.moveTo(0,y*cellSize);
            ctx.lineTo(W,y*cellSize);
            ctx.stroke();
          }
        }

        ctx.fillStyle = currentSkin.obstacle;
        obstacles.forEach(o=>{
          ctx.fillRect(o.x*cellSize,o.y*cellSize,cellSize,cellSize);
        });

        powerups.forEach(p=>{
          ctx.fillStyle = currentSkin.powerup;
          ctx.beginPath();
          ctx.arc(p.x*cellSize+cellSize/2,p.y*cellSize+cellSize/2,cellSize/3,0,Math.PI*2);
          ctx.fill();
          ctx.fillStyle = darkMode ? '#000' : '#fff';
          ctx.font = `${cellSize/2}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          let symbol = '?';
          switch(p.type){
            case 'speedup': symbol = '‚ö°'; break;
            case 'slowdown': symbol = 'ü¢†'; break;
            case 'scoreMulti': symbol = '‚≠ê'; break;
            case 'shrink': symbol = '‚úÇÔ∏è'; break;
          }
          ctx.fillText(symbol,p.x*cellSize+cellSize/2,p.y*cellSize+cellSize/2);
        });

        if(food){
          ctx.fillStyle = currentSkin.food;
          ctx.beginPath();
          ctx.arc(food.x*cellSize+cellSize/2,food.y*cellSize+cellSize/2,cellSize/2.5,0,Math.PI*2);
          ctx.fill();
        }

        snake.forEach((seg,i)=>{
          ctx.fillStyle = (i===snake.length-1) ? currentSkin.snakeHead : currentSkin.snakeBody;
          ctx.strokeStyle = darkMode ? '#0008' : '#fff4';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.rect(seg.x*cellSize,seg.y*cellSize,cellSize,cellSize);
          ctx.fill();
          ctx.stroke();
        });
      }

      // Improved auto play function with collision avoidance
      function getSmartDirection() {
        if (!food) return dir;
        
        const head = snake[snake.length - 1];
        
        // Check if a position is safe
        function isSafe(x, y) {
          // Check bounds
          if (!wrap && (x < 0 || x >= grid || y < 0 || y >= grid)) return false;
          
          // Wrap coordinates
          let checkX = x;
          let checkY = y;
          if (wrap) {
            if (checkX < 0) checkX = grid - 1;
            else if (checkX >= grid) checkX = 0;
            if (checkY < 0) checkY = grid - 1;
            else if (checkY >= grid) checkY = 0;
          }
          
          // Check collisions with body
          if (snake.some(s => s.x === checkX && s.y === checkY)) return false;
          
          // Check collisions with obstacles
          if (obstacles.some(o => o.x === checkX && o.y === checkY)) return false;
          
          return true;
        }
        
        // Get all possible directions
        const directions = [
          {x: 0, y: -1}, // up
          {x: 0, y: 1},  // down
          {x: -1, y: 0}, // left
          {x: 1, y: 0}   // right
        ];
        
        // Filter out opposite direction and unsafe moves
        const safeDirs = directions.filter(d => {
          // Don't go opposite to current direction
          if (d.x === -dir.x && d.y === -dir.y) return false;
          
          // Check if this direction is safe
          const newX = head.x + d.x;
          const newY = head.y + d.y;
          return isSafe(newX, newY);
        });
        
        if (safeDirs.length === 0) {
          // If no safe direction, try to keep current direction if possible
          const currentNewX = head.x + dir.x;
          const currentNewY = head.y + dir.y;
          if (isSafe(currentNewX, currentNewY)) {
            return dir;
          }
          // Otherwise return any direction (will likely end game)
          return dir;
        }
        
        // Choose the best direction towards food
        const dx = food.x - head.x;
        const dy = food.y - head.y;
        
        // Handle wrapping for distance calculation
        let adjustedDx = dx;
        let adjustedDy = dy;
        
        if (wrap) {
          if (Math.abs(dx) > grid / 2) {
            adjustedDx = dx > 0 ? dx - grid : dx + grid;
          }
          if (Math.abs(dy) > grid / 2) {
            adjustedDy = dy > 0 ? dy - grid : dy + grid;
          }
        }
        
        // Sort directions by how close they get us to food
        safeDirs.sort((a, b) => {
          const distA = Math.abs(adjustedDx - a.x) + Math.abs(adjustedDy - a.y);
          const distB = Math.abs(adjustedDx - b.x) + Math.abs(adjustedDy - b.y);
          return distA - distB;
        });
        
        return safeDirs[0];
      }

      function update(){
        if(paused || !playing || gameOver) return;

        // Auto control with improved logic
        if (autoPlay) {
          nextDir = getSmartDirection();
        }

        dir = nextDir;
        let head = snake[snake.length-1];
        let newHead = {x: head.x + dir.x, y: head.y + dir.y};

        if(wrap){
          if(newHead.x < 0) newHead.x = grid-1;
          else if(newHead.x >= grid) newHead.x = 0;
          if(newHead.y < 0) newHead.y = grid-1;
          else if(newHead.y >= grid) newHead.y = 0;
        } else {
          if(newHead.x < 0 || newHead.x >= grid || newHead.y < 0 || newHead.y >= grid) {
            endGame('Hit wall');
            return;
          }
        }

        if(snake.some(s=>s.x===newHead.x && s.y===newHead.y)){
          endGame('Hit body');
          return;
        }
        if(obstacles.some(o=>o.x===newHead.x && o.y===newHead.y)){
          endGame('Hit obstacle');
          return;
        }

        snake.push(newHead);

        if(food && newHead.x === food.x && newHead.y === food.y){
          lengthTarget += 1;
          score += 10;
          if(score > highScore) highScore = score;
          placeFood();
          if(Math.random() < 0.3) placePowerup(); // 30% chance for powerup
        }

        for(let i=0;i<powerups.length;i++){
          let p = powerups[i];
          if(newHead.x === p.x && newHead.y === p.y){
            activatePowerup(p.type);
            powerups.splice(i,1);
            pwrCount.textContent = powerups.length;
            break;
          }
        }

        while(snake.length > lengthTarget){
          snake.shift();
        }

        scoreEl.textContent = score;
        highEl.textContent = highScore;
        lengthEl.textContent = snake.length;

        if(snake.length > longestLength) {
          longestLength = snake.length;
          longest.textContent = longestLength;
        }
        played.textContent = gamesPlayed;

        draw();
      }

      function activatePowerup(type){
        switch(type){
          case 'speedup':
            speed = Math.min(speed + 4, 25);
            speedInput.value = speed;
            speedDisplay.textContent = speed;
            statusChip.textContent = 'Speed Up! ‚ö°';
            break;
          case 'slowdown':
            speed = Math.max(speed - 3, 3);
            speedInput.value = speed;
            speedDisplay.textContent = speed;
            statusChip.textContent = 'Slow Down üê¢';
            break;
          case 'scoreMulti':
            score += 20;
            statusChip.textContent = 'Score Bonus ‚≠ê';
            break;
          case 'shrink':
            lengthTarget = Math.max(1, lengthTarget - 3);
            if(snake.length > lengthTarget){
              snake = snake.slice(snake.length - lengthTarget);
            }
            statusChip.textContent = 'Shrink ‚úÇÔ∏è';
            break;
        }
        setTimeout(()=>{
          statusChip.textContent = autoPlay ? 'Auto Play ON' : 'Playing';
        }, 1500);
      }

      function gameLoop(){
        update();
        if(playing && !paused && !gameOver) {
          clearInterval(gameInterval);
          gameInterval = setInterval(gameLoop, 1000 / speed);
        }
      }

      function startGame(){
        if(playing && !gameOver) return;
        
        if(gameOver) {
          resetGame();
        }
        
        playing = true;
        paused = false;
        gameOver = false;
        if(!food) placeFood();
        statusChip.textContent = autoPlay ? 'Auto Play ON' : 'Playing';
        speed = parseInt(speedInput.value);
        speedDisplay.textContent = speed;
        gameInterval = setInterval(gameLoop, 1000 / speed);
        canvas.focus();
      }

      function pauseGame(){
        if(!playing || gameOver) return;
        paused = !paused;
        statusChip.textContent = paused ? 'Paused' : (autoPlay ? 'Auto Play ON' : 'Playing');
        if(!paused){
          gameInterval = setInterval(gameLoop, 1000 / speed);
        } else {
          clearInterval(gameInterval);
        }
      }

      function togglePause(){
        if(!playing || gameOver) return;
        pauseGame();
      }

      function endGame(reason){
        clearInterval(gameInterval);
        playing = false;
        paused = false;
        gameOver = true;
        gamesPlayed++;
        lastScore.textContent = score;
        statusChip.textContent = `Game Over! (${reason})`;
        obCount.textContent = obstacles.length;
        pwrCount.textContent = powerups.length;
        speedDisplay.textContent = speed;
        lengthEl.textContent = snake.length;
        if(score > highScore) highScore = score;
        highEl.textContent = highScore;
        
        if(autoPlay) {
          autoPlay = false;
          autoBtn.classList.remove('auto-active');
        }
      }

      // Keyboard input
      window.addEventListener('keydown', e => {
        if(!playing || paused || gameOver || autoPlay) return;
        switch(e.key){
          case 'ArrowUp':
          case 'w':
          case 'W':
            if(dir.y!==1) nextDir = {x:0,y:-1};
            break;
          case 'ArrowDown':
          case 's':
          case 'S':
            if(dir.y!==-1) nextDir = {x:0,y:1};
            break;
          case 'ArrowLeft':
          case 'a':
          case 'A':
            if(dir.x!==1) nextDir = {x:-1,y:0};
            break;
          case 'ArrowRight':
          case 'd':
          case 'D':
            if(dir.x!==-1) nextDir = {x:1,y:0};
            break;
        }
      });

      // Mobile buttons
      upTouch.onclick = () => { 
        if(!autoPlay && playing && !paused && !gameOver && dir.y!==1) nextDir = {x:0,y:-1}; 
      };
      downTouch.onclick = () => { 
        if(!autoPlay && playing && !paused && !gameOver && dir.y!==-1) nextDir = {x:0,y:1}; 
      };
      leftTouch.onclick = () => { 
        if(!autoPlay && playing && !paused && !gameOver && dir.x!==1) nextDir = {x:-1,y:0}; 
      };
      rightTouch.onclick = () => { 
        if(!autoPlay && playing && !paused && !gameOver && dir.x!==-1) nextDir = {x:1,y:0}; 
      };

      // Controls event listeners
      startBtn.onclick = () => {
        startGame();
      };
      
      pauseBtn.onclick = () => {
        if(playing && !gameOver) {
          togglePause();
        } else if(paused) {
          paused = false;
          playing = true;
          statusChip.textContent = autoPlay ? 'Auto Play ON' : 'Playing';
          gameInterval = setInterval(gameLoop, 1000 / speed);
        }
      };
      
      restartBtn.onclick = () => {
        clearInterval(gameInterval);
        resetGame();
      };
      
      autoBtn.onclick = () => {
        autoPlay = !autoPlay;
        if(autoPlay) {
          autoBtn.classList.add('auto-active');
          statusChip.textContent = 'Auto Play ON';
          if(!playing || gameOver) {
            startGame();
          }
        } else {
          autoBtn.classList.remove('auto-active');
          statusChip.textContent = playing ? 'Playing' : 'Ready';
        }
      };

      speedInput.oninput = () => {
        speed = parseInt(speedInput.value);
        speedDisplay.textContent = speed;
        if(playing && !paused && !gameOver){
          clearInterval(gameInterval);
          gameInterval = setInterval(gameLoop, 1000 / speed);
        }
      };

      gridInput.oninput = () => {
        grid = parseInt(gridInput.value);
        cellSize = W / grid;
        resetGame();
      };

      obstacleMode.onchange = () => {
        obstacles = generateObstacles(obstacleMode.value);
        draw();
      };

      powerupsSel.onchange = () => {
        powerups = [];
        pwrCount.textContent = 0;
        draw();
      };

      skinSel.onchange = () => {
        currentSkin = skins[skinSel.value];
        draw();
      };

      wrapSel.onchange = () => {
        wrap = wrapSel.value === 'true';
      };

      // Save/load state with localStorage
      function saveGame(){
        const state = {
          snake, dir, nextDir, food, obstacles, powerups,
          score, highScore, lengthTarget, speed, grid,
          gamesPlayed, longestLength,
          wrap, autoPlay, gameOver, playing, paused,
          darkMode,
          skin: skinSel.value,
          obstacleMode: obstacleMode.value,
          powerupsOn: powerupsSel.value,
        };
        
        try {
          localStorage.setItem('tndSnakeGame', JSON.stringify(state));
          statusChip.textContent = 'Game Saved!';
        } catch (e) {
          statusChip.textContent = 'Save Failed!';
        }
        
        setTimeout(()=>{
          statusChip.textContent = gameOver ? 'Game Over!' : (playing ? (paused ? 'Paused' : (autoPlay ? 'Auto Play ON' : 'Playing')) : 'Ready');
        }, 1500);
      }
      
      function loadGame(){
        try {
          const saved = localStorage.getItem('tndSnakeGame');
          if(!saved) {
            statusChip.textContent = 'No saved game found!';
            setTimeout(()=>{
              statusChip.textContent = gameOver ? 'Game Over!' : (playing ? (paused ? 'Paused' : (autoPlay ? 'Auto Play ON' : 'Playing')) : 'Ready');
            }, 1500);
            return;
          }
          
          const state = JSON.parse(saved);
          snake = state.snake || [{x:Math.floor(grid/2), y:Math.floor(grid/2)}];
          dir = state.dir || {x:1,y:0};
          nextDir = state.nextDir || {x:1,y:0};
          food = state.food || null;
          obstacles = state.obstacles || [];
          powerups = state.powerups || [];
          score = state.score || 0;
          highScore = state.highScore || 0;
          lengthTarget = state.lengthTarget || snake.length;
          speed = state.speed || parseInt(speedInput.value);
          grid = state.grid || grid;
          gamesPlayed = state.gamesPlayed || 0;
          longestLength = state.longestLength || 1;
          wrap = state.wrap !== undefined ? state.wrap : true;
          autoPlay = state.autoPlay || false;
          gameOver = state.gameOver || false;
          playing = state.playing || false;
          paused = state.paused || false;
          darkMode = state.darkMode !== undefined ? state.darkMode : true;
          skinSel.value = state.skin || 'neon';
          currentSkin = skins[skinSel.value];
          obstacleMode.value = state.obstacleMode || 'none';
          powerupsSel.value = state.powerupsOn || 'on';

          speedInput.value = speed;
          gridInput.value = grid;
          wrapSel.value = wrap ? 'true' : 'false';
          
          if(autoPlay) {
            autoBtn.classList.add('auto-active');
          } else {
            autoBtn.classList.remove('auto-active');
          }

          updateTheme();
          updateStats();
          resizeCanvas();
          draw();

          statusChip.textContent = 'Game Loaded!';
          
          if(playing && !paused && !gameOver) {
            gameInterval = setInterval(gameLoop, 1000 / speed);
          }
        } catch (e) {
          statusChip.textContent = 'Load Failed!';
        }
        
        setTimeout(()=>{
          statusChip.textContent = gameOver ? 'Game Over!' : (playing ? (paused ? 'Paused' : (autoPlay ? 'Auto Play ON' : 'Playing')) : 'Ready');
        }, 1500);
      }

      document.getElementById('saveBtn').onclick = saveGame;
      document.getElementById('loadBtn').onclick = loadGame;

      function updateStats(){
        scoreEl.textContent = score;
        highEl.textContent = highScore;
        speedDisplay.textContent = speed;
        lengthEl.textContent = snake.length;
        played.textContent = gamesPlayed;
        longest.textContent = longestLength;
        obCount.textContent = obstacles.length;
        pwrCount.textContent = powerups.length;
      }

      // Load saved data on startup
      try {
        const saved = localStorage.getItem('tndSnakeGame');
        if (saved) {
          const state = JSON.parse(saved);
          highScore = state.highScore || 0;
          gamesPlayed = state.gamesPlayed || 0;
          longestLength = state.longestLength || 1;
          updateStats();
        }
      } catch (e) {
        console.log('No previous save found');
      }

      // Initial setup
      resetGame();

      // Autofocus canvas on load
      window.onload = () => {
        canvas.focus();
      };
    })();
    console.log("Scripts Loaded Successfully");
  </script>
</body>
</html>
